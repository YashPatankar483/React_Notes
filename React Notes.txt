#React Intro
React is a Library or a frontend web-framework meaning it consist of pre written code which we can use it to build our complex applications faster and easily.

In react you build your application by following the component tree.
Your react application is browkendown into components.
At the top there is your appliation represented as a component, which is made up of n no. of child components.
Each of the components can be reused and customized. Thus reducing the code redundancy.

In react we represent each component in the html file by a reference which looks similar to the html tag as if we have built our custom html element.

Components are made by combining 3 different files together i.e html, css and js. Each defining the structure, styling and separate functionality for that component. 
The components can interact with the server independently and update themselves without refreshing the entire webpage or application.

Diffing Process (Reconciliation) chatgpt:
In React, "diffing" refers to the process of efficiently updating the user interface (UI) by determining which parts of the UI need to be updated in response to changes in application state. This process is also known as "reconciliation."

When a component's state or props change, React needs to update the UI to reflect those changes. However, updating the entire UI every time there's a change can be inefficient, especially in complex applications with many components.

React's diffing algorithm optimizes this process by comparing the current state of the UI (virtual DOM) with the previous state and calculating the minimal set of changes needed to update the UI. It identifies the differences between the previous and current UI states and applies only those changes to the real DOM, rather than re-rendering the entire UI.

The diffing algorithm operates on the virtual DOM, a lightweight representation of the actual DOM in memory. When a component's state or props change, React re-renders the component and updates the virtual DOM. Then, it compares the updated virtual DOM with the previous one to determine the minimal set of changes needed to update the real DOM.

Note: For Initial practice I am going to use the "codesandbox" which is the online code editor especially

In react projects we are going to deal with 3 types of files: html, css and js. 
Among these 3, 99% of times we are going to work with the .js file. 
We are going to touch the html file only once- just to include the .css and .js files and to include the <div> tag having id = "root". Because it is really the root of our react application and everything we are going to add will get inside this root <div>.

Now the next step involves installing the dependencies. We are going to use React to create the project so the "react" becomes one of our projects dependencies and also there is "react-dom" package which we will require. So install both of them and require them inside the .js file so that we can use the react.:
var React = require("react");
var React-DOM = require("react-dom");

Now we are free to use the features of the react-  Lets render "Hello World!" on our website.
Use the render() function of the react-dom package to render any html element. It basically takes 3 inputs- 
render(What to render, Where to render,optional- callback function which tells when the render function got completed);
eg:
React-DOM.render(<h1>Hello World!</h1>, document.getElementById("root"));

Equivalent Plain JavaScript code for the above code:
var h1 = document.createElement("h1");
h1.innerHTML = "Hello World!";
document.getElementById("root").appendChild(h1);

Now the "Hello World!" is displayed on the screen. 
We were able to write plain HTML inside the javaScript file. And it is pure magic. Is is only possible because of JSX.

*What is JSX?
JSX is the core of React
JSX files are the js files which contain html in it.
So React works by creating these JSX files.
Behind the scenes the compiler picks our html and converts this into actual js code.
JSX comes from the React Module.
As JSX allows us to write html inside the js. More than that it also allows us to write js inside the html of the JSX file.
for eg:
import React from "react";
import ReactDOM from "react-dom";

const name = "Yash";
const luckyNo = 3;

ReactDOM.render(
  <div>
    <h1>Hello {name}!</h1>
    <p>My lucky number is {luckyNo}</p>
  </div>,
  document.getElementById("root")
);

In the above code constants name and luckyNo which is a js code are used inside html using {}. This curly braces tells the compiler that it is not the part of html rather it is a js code.

What is Bable?
So the compiler comes from the React Module.
The React Module contains Bable which is a JavaScript Compiler.
The Bable converts next generation JavaScript like ES6,7,8 ,etc into ES5 which any browser can understand.
So the Bable converts the JSX into plane JS which any browsers can understand.
Above code compiled by Bable to plain JavaScript:
import { jsx as _jsx } from "react/jsx-runtime";
ReactDOM.render( /*#__PURE__*/_jsx("h1", {
  children: "Hello World!"
}), document.getElementById("root"));

Bable also allows us to use the constructs of next generation JavaScript.
So instead of requiring the dependencies we will "import" them so that our code becomes more modularized

import React from "react";
import React-DOM from "react-dom";

The render() method can take only one html element as a parameter.
If we try to include more than one html elements inside it then the code will crash.
But we can include an html element which has other html elements embeded into it for eg:
<div><h1>Hello World!</h1><p>This is a paragraph</p></div>
eg: React-DOM.render(<div><h1>Hello World!</h1><p>This is a paragraph</p></div>, document.getElementById("root"));

Adding JS Expressions inside html:
<p>My lucky number is {Math.ceil(Math.random() * 10)}</p>
As shown above you can add javaScript expressions inside the html which will get evaluated and enter the result to the html.
But you cannot add statements inside the html of JSX.

You can embed string constants of variables inside the html as follows:
<h1>Hello {fName + " " + lName}!</h1>
<h1>Hello {`${fName} ${lName}`}!</h1>     // This approach of adding strings is known as "Template Literals" in other languages it is known as string interpolation. It is the feature of ES6. Using tempelate literals we can add strings, multi lined strings and also interpolate strings.

*JSX Attributes and Styling React Elements:

In JSX file if we write the attributes in the way we were in the pure html file then the browser will give an error. for eg:
ReactDOM.render(
  <div>
    <h1 class="red" contenteditable="true">My Favourite Foods</h1>
    <ul>
      <li>Dahi Sev Puri</li>
      <li>Burger</li>
      <li>Noodles</li>
    </ul>
  </div>,
  document.getElementById("root")
);

But in the above case the class attribute will work fine thus producing its effect because the react will handle it behind the scenes. But still we will get an error saying: 
Warning: Invalid DOM property `class`. Did you mean `className`?
    in h1 (at src/index.js:6)
    in div (at src/index.js:5)

We get this error because in the end the html in the JSX file gets converted into javaScript. So the 'class' is not the property of the DOM element thus producing the error. So instead of 'class' the javascript property to set the class attribute is 'className'. So the correct code will be:   
<h1 className="red" c>My Favourite Foods</h1>

In javaScript: The className property of the Element interface gets and sets the value of the class attribute of the specified element.

~ Set the type of the "index.js" link tag to "text/JSX" else we will get an error for including the html in the javaScript file.

Note: All the attributes which are used in html can be used in the JSX file but using camel casing.
for eg:
ReactDOM.render(
  <div>
    <h1 className="red" contentEditable="true">My Favourite Foods</h1>
    <ul>
      <li>Dahi Sev Puri</li>
      <li>Burger</li>
      <li>Noodles</li>
    </ul>
  </div>,
  document.getElementById("root")
);

Also note that the html elements inside the JSX needs to be terminated otherwise it will give an error.
for eg: <img src="shfsfhsfj">   //will get an error because the tag is not an opening tag or it is not closed with the closing tag
<img src="dsfsfsf" />   //No error

We can also insert javascript as an attribute. for eg:
import React from "react";
import ReactDOM from "react-dom";

const imgSrc = "https://picsum.photos/200";

ReactDOM.render(
  <div>
    <h1 className="heading" contentEditable="true" spellCheck="false">
      My Favourite Foods
    </h1>
    <div>
      <img src={imgSrc} alt="" />
    </div>
  </div>,
  document.getElementById("root")
);

* Inline styling for react elements:
In pure html we use to apply inline styling to our elements using the "style" attribute. Similarly we can do so in the react as well. But there is a small twist.
You cant just go and use the 'style' property and put the css rules in there. This will get us an error.
Because we are in JSX file and not inside the html file. In JSX all the stuff in there is nothing but javaScript. So we have to put javaScript and not css.
So the 'style' attribute of the JSX accepts an JavaScript Object. This javaScript object must contain the css rules to be applied. But the css rules are to be in the form of js properties in camel casing.
Since we are assigning javaScript object to the style attribute of the fake html, it must be wrapped in the curly braces because afterall it is a javaScript expression. If we want to include javaScript into the fake html then we must wrap it inside curly braces{javascript}. 

import React from "react";
import ReactDOM from "react-dom";

const styling = {
  color: "red",
  fontSize: "50px",
  border: "1px solid black",
};

styling.color = "green";

ReactDOM.render(
  <div>
    <h1 style={styling}>Hello World!</h1>
    <p style={{ color: "blue" }}>I am moon</p>
  </div>,
  document.getElementById("root")
);

Use : If we want our element to change its style if something changes for eg: the user makes some changes or it is the new day. We can make changes to the style, As we have made changes to the h1 element. Using : styling.color = "green";

# React Components
Entire complex website is broken down into small compact individual resuable components. 
These components make up the entire website.

Custom components are created creating functions and note that the name of the function must follow Pascal Casing:
Lets create an heading component-

function Heading(){
	return <h1>My Favourite Food</h1>;
}

Our component is now created and ready to be used.
Now since this component has been created inside the index.js there is no need to import the component. We can directly use it as if it is an html element-
Inside the React Code:
ReactDOM.render(
  <div>
    <Heading />                  // This is how we include custom components in our JSX file.
    <ul>
      <li>Bacon</li>
      <li>Jamon</li>
      <li>Noodles</li>
    </ul>
  </div>,
  document.getElementById("root")
);

This is where Pascal Casing comes into handy because the React can diffirenciate between the html elements(lower cased) and the custom components(Pascal cased).
Once the compiler reaches the <Heading /> component tag, it searches for the component function and executes it. Which results in returning the js html(fake) element in place of the heading tag.

*But it is not the best practice to create components and use it inside the same file i.e index.js.
Components must be created inside the separate special JSX files and imported from there.
JSX files are the way we represent our components.
Once we have created our component inside the JSX file we have to export it so that we can access that component inside other files.

First create a .jsx file.

import React from "react";   // Because we are including JSX code in the file

function Heading(){
	return <h1>My Favourite Food</h1>;
}

export default Heading;

Now we can import this component in our index.js file:
import Heading from "./Heading"         // There is no need to add .jsx extension. Because it is the ES6 feature that we can skip the .js and .jsx extensions

Now we have created and configured the component.

*Common & Best Practice: All the components of your website must be configured or included into the root component i.e App. And this App component <App /> which contains the structure of your website is included into index.js. 

# ES6 import, export and modules
Modules : We were able to create custom files which created independent packaged bits of functionality which depending on what we need from it we were able to import them in different files. These files are refered to as modules.

I have a main file on whcih I am working named index.js. 
And also I have created a new file named math.js. Inside which I have defined a 'const pi = 3.14'.
I have exported this constant 'pi' as default.

"Now since I have exported this const pi, Our math.js file becomes a Module"
eg:
math.js
const pi = 3.141592;

export default pi;                 // this line makes the math.js as module

Now we can use this module to access the value of pi by importing it inside any file.
eg:
index.js             
import React from "react";
import ReactDOM from "react-dom";
import pi from "./math.js";                         // This line imports the constant pi from math.js file and it is ready to be used in index.js

ReactDOM.render(
  <ul>
    <li>{pi}</li>
    <li>2</li>
    <li>3</li>
  </ul>,
  document.getElementById("root")
);

We are exporting constant pi as default. It means that if the math.module has multiple functionalities or properties which can be exported then the one which is defined as default will get exported when we write: import pi from "./math.js";
The other functionalities and properties can be exported and imported but it has different methods which we are going to learn soon.
* Note: In case of importing default, then the name of an import can be anything - import anyName from "./math.js";
anyName will contain the value of the default export. In our above eg- it will be 3.141592

Lets say we want to export more than one thing
eg:
const pi = 3.141592;

function doublePi() {
  return pi * 2;
}

function triplePi() {
  return pi * 3;
}

export default pi;
export { doublePi, triplePi };

Now in addition to the default export we want to export other non default things like - doublePi() and triplePi().
We can export non default exports by wrapping them into curly braces{}. as shown above.

How to import non default exports?
To import non default exports, include all other required non default stuff beside the default export(if included) followed by the , inside the curly braces{}.
for eg: import pi, { doublePi, triplePi } from "./math.js";

Note that : The names of the non default exports must have the same name as the exports cause the computer would not be able to locate them if mispelled.
It is able to locate the default export because there is only one default export per file.

The concept of Modules, Imports and Exports help break down our complex large code into smaller parts called modules.
The concept of import and export comes from ES6. and we can use it in react because of Bable.
We can include the modules using require() also for eg: var react = require("react"); ...But this is the feature of nodeJS.

* Not recommended: If we want to import all the things from the module without making any difference in default and non default things. Then we can do so by:
import * as pi from "./math.js";
This will import everything from math.js module.
Now here 'pi' is an object which contains all the stuff - default, doublepi() and triplepi() in the math.js.
We can access the required functionalities or properties by- pi.default or pi.doublepi(), etc.

# Creating a React App
There are many ways we can create a React app- (For more ways visit: www.react.dev > Installation)
Here I am going to create a react app using two ways:

1) Using Vite Bundler: 
	Creates a light weight react app.
	Does not contain react-scripts.
	
	Inside terminal run the following command: npm create vite@latest
	It will ask no. of questions...so select
	1. Give project name
	2. Select React
	3. Select JavaScript
	This will start creating the basic react app.
	
	npm run dev
	
2) This way is not recommended since it is depricated
	This method creates heavy react app and takes more time in creating the app.
	
	Inside terminal run the following command: npx create-react-app project-name
	It will take time to create the app.
	
	npm start
	
# Props in React

	Props is the important concept of the components.
	The below code contains repetative elements. This makes our code long and clutured.
	The h2, img, and 2 p tags represent a single contact in the below code.
	So instead of repeating the code multiple times to avoid cluttering, we can create a component and use it multiple times.
	<h1>My Contacts</h1>

    <h2>Beyonce</h2>
    <img
      src="https://blackhistorywall.files.wordpress.com/2010/02/picture-device-independent-bitmap-119.jpg"
      alt="avatar_img"
    />
    <p>+123 456 789</p>
    <p>b@beyonce.com</p>

    <h2>Jack Bauer</h2>
    <img
      src="https://pbs.twimg.com/profile_images/625247595825246208/X3XLea04_400x400.jpg"
      alt="avatar_img"
    />
    <p>+987 654 321</p>
    <p>jack@nowhere.com</p>

    <h2>Chuck Norris</h2>
    <img
      src="https://i.pinimg.com/originals/e3/94/47/e39447de921955826b1e498ccf9a39af.png"
      alt="avatar_img"
    />
    <p>+918 372 574</p>
    <p>gmail@chucknorris.com</p>
	
	*Component for above code:
	function Card() {
	return (
		<h2>Beyonce</h2>
		<img src="https://pbs.twimg.com/profile_images/625247595825246208/X3XLea04_400x400.jpg" alt="avatar_img"/>
		<p>+123 456 789</p>
		<p>b@beyonce.com</p>
	)
	}
	
	And inside the render() we can just use the component:
	<Card />
	<Card />
	<Card />
	
	But there lies problem with the above component- It renders the same data everytime we render the component.
	What we want is the component should render the data corresponding to the contact which we want to display. i.e 1st I want to dispaly Beyonce, 2nd Andrew Garfield 3rd Eren Jeager. 
	
	How can we do so? = Using Props.
	Props are to the components like attributes are to the html elements.
	For eg: Consider <input /> element. We can define no. of attributes for the <input /> element- type, placeholder, value, etc. Which we can assign some custom values
		<input type="text" placeholder="Enter your Name" value="Yash Patankar" />
	What these attributes does is- It helps pass the custom information to the elements via the attributes.
	Now we can access the values of the attributes using dot notation- input.placeholder, input.value, etc. We can tell that the elements are like objects and attributes its properties. But the attributes are already defined and we cannot go and create our own new custom attributes.
	
	But in React world we can think the react component as the custom html element. Then we can define custom attributes and we call them Props (properties).
	We define the props for custom components in exact similar fashion as we define attributes for html elements.
	For eg: <Cards name="Beyonce" img="https://pbs.twimg.com/profile_images/625247595825246208/X3XLea04_400x400.jpg" tel="123456789" email="b@beyonce.com"/>
	
	To get hold of these props add the name to the inputs to access the pieces of data that are sent over. We customary call or name this input as props.
	This props receives an object having props as its properties. These properties can be used to insert the values in place of hard coded parts.
	function Card(props) {
	return (
		<h2>{props.name}</h2>
		<img src={props.img} alt="avatar_img"/>
		<p>{props.tel}</p>
		<p>{props.email}</p>
	)
	}
	
	This solves our problem of reusing components with different pieces of information.

	Now to add styling to our component we can do so by adding inline styling or external styling(using className). But this has to go inside the jsx and not inside the custom component for eg: not-> <Card className="styling" /> Here the className will be treated as a prop. 
	
# Mapping Data to Components
	If we go on hard coding the values for our Components, then it makes our code repetative and cluttered. Thus to prevent this eyesore we can create these components dynamically by looping over the components and mapping the data simultaneously.
	So here the map() function of an Array comes into handy to create the components dynamically.
	Instead of hard coding the components like:
	<Card name={contact[0].name} imgURL={contact[0].img} tel={contact[0].phone} email={contact[0].email} />
	<Card name={contact[1].name} imgURL={contact[1].img} tel={contact[1].phone} email={contact[1].email} />
	<Card name={contact[2].name} imgURL={contact[2].img} tel={contact[2].phone} email={contact[2].email} />
	
	We can dynamically create these components using map():
	function createCards(contact) {
		return <Card name={contact.name} imgURL={contact.img} tel={contact.phone} email={contact.email} />
	}       // This function returns the Card component. Note that this function is not the component by itself it just returns the component. The basic idea for creating this function is to create the Card component once it is been called. It accepts an input parameter named 'contact'. Here in our case the 'contact' accepts an object. This object contains the details or data which is required by the component to display the custom data. This data can be accessed using dot notation as shown above.
	
	Now to create n no. of components without needing to hard code each component, We will make use of map().
	The map method over an array.
	We have created the contacts array which stores objects so that it resembles the components(means the object has all the details or data which has to be used in a components).
	
	{contacts.map(createCards)}
	
	The above line creates n no. of components using map()
	The map() basically takes the object one by one from the contacts array and it passes it to the createCards() function. And this function returns the customized Card component for the given contact details.
	
# Array Functions

*Map -Create a new array by doing something with each item in an array.
	For in order to do something to each element we have to pass a function to the map().
	function double(x) {
		return x*2
	}
	var newNumbers = numbers.map(double);
	console.log(newNumbers);
	
	The map function loops over the numbers array and for each element it calls the double function to process the element. This double function returns the value which is used by map function to create the new array which we are capturing inside the newNumbers.

	Instead of creating the double function separately we can pass the anonymous function to the map.
	Best way:
	var newNumbers = numbers.map(function (x) {
		return x*2
	});
	
	This can be done with the forEach() loop but the map() makes it more easy beacuse the foreach() function does not create any new array by itself. We implicitly had to create it. for eg:
	
	var newNumbers = [];
	
	numbers.forEach(function (x) {
		newNumbers.push(x*2);
	});
	This method is roundbout to create new array.
	
*Filter - Create a new array by keeping the items that return true.
	It loops over the array and creates a new array containing the only items from the parent array which follow the particular condition.
	
	Implementation:
	numbers.filter(function (x) {
		return x > 10;                  // If this condition is then and only the filter will include the x in the new array.
	});
	
*Reduce - Accumulate a value by doing something to each item in an array.
	This function basically takes the function whcih accepts two parameters- accumulator and currentvalue for eg. 
	The accumulator at the first iteration is equal to the first element and the currentvalue equal to the 2nd element. The function then performs the operation and returns the value to the reduce. The reduce does something and now the accumulator's value is equalt to the result of the last return. and the current value is equal to the third element. This process is repeated until the reduce function iterates over all the elements of an array.
	Note: Reduce function returns the value and not array.
	numbers.reduce(function (accumulator, currentvalue) {
		return accumulator + currentvalue;
	});
	
*Find - find the first item that matches from an array.
	Similar to the filter function but the only difference is, it stops the iteration once the input function returns true.
	
	numbers.find(
		function (num) {
			return num > 10;
		}
	);
	
	will return output as 56
	
*FindIndex - find the index of the first item that matches.           (ES6)
	Exactly similar to the find function. The only difference is returns the index of the element which satifies the condition
	numbers.findIndex(
		function (num) {
			return num > 10;
		}
	);
	
#Fat Arrow

Fat arrow are nothing but functions. These functions are no different from the basic functions which we normally create, but the difference lies in its syntax. These are the part of ES6 feature. Using these fat arrow we only reduce the length of our code and nothing more.

Basic function-
function name(parameter) {
 statements;
 return value;
}

Anonymous function- functions without name- used for input functions

numbers = [1,2,3,45,7];

var newArray = numbers.map( function (parameter) {
	return value;
});

Fat Arrow- Anonymous functions reduced further

numbers = [1,2,3,45,7];

var newArray = numbers.map((parameter) => {
	return value;
});

We can also reduce them further if we only have a single input parameter and single statement.
var newArray = numbers.map( parameter => value);

#React Conditional Rendering

 Conditional Rendering is the process of rendering the components or jsx based on condition. There are two ways we can achieve this.

*Using Ternary Operator -
	
	Condition ? If ture value : If false value;
	
	This is an alternative for if else statements. Unlike if else statements the above is an expression- means it gets replaced by a value based on condition.
	So in some cases to make our code consciese we can make use of the ternary operator in place of if elese statements.
	
	Most of the times in react we need to render the components or some elements of jsx conditionally. So instead of defining a seperate function to conditionally render components we can do this inline. Note that the jsx elements only accepts expression or a value. So it is clear that we cant use the if-else statements to render the the jsx element or a component. Because the if-else statments will not get replaced by the value. So here the ternary operator has its role to play. Because the expression formed using the ternary operator will get replaced by a value.
	
	<p> (num === 5 ? "No. is equal to 5" : "No. is not equal to 5") </p> -> jsx element
	
	* Suppose if we want to render nothing if the condition is not met then we can retrun null value - for eg:
		{ (currentTime > 12) ? <h1>Why you are still working?</h1> : null }
	The above statement will display nothing if the condition is not met. But if currentTime is greater than 12 say its 3pm then the h1 element will get rendered.
	
	But there is a simpler way to do this with the help of Logical And Operator.

*Using And Operator (Recommended way in react)-

	(Expression && Expression) - results in either true or false value
	The javascript leverages the concept of and operation to save time. It will only check the second expression if and only if the first codition is true.
	Otherwise it will not.
	So React leverages this feature of javascript to render the element or component.
	   { (currentTime > 12) && <h1>Why are you still working?</h1> }
	   
	   If only the first condition or expression is true the second element will get evaluated otherwise it will not. This is the feature of react.
	   Above code is an alternative for -	{ (currentTime > 12) ? <h1>Why you are still working?</h1> : null }
	   

# State in React (Imperative vs Declarative Programming)

So far we haven't build any interactive website usig React. So to build it we must first understand what does it mean by state in react. 
State is the centeral concept of doing things with React.

State can be best summarized using the following equation:

			UI = f(State)
			
			The UI user sees on your website is the function of the State. Depending on the State the UI will appear in a certain way to the user.
			For eg - Think of your website as analogous to water. So the appearance of water depends on the Temperature. Here Temperature is State. So as State i.e. Temperature changes the appearance of water also changes. At 34 deg Celcius water will appear as liquid. At -10 deg Celcius water will appear as solid i.e. ice. So we can say that the appearance of water depends on its State.
			
			Similarly the UI of our react app depends upon State. 
			The changes in UI reflect the changes in the State.
			
			Now how it is done with coding?
			Lets say we have developed a to-do list app using react. It has following components: App > List > Paragraph
			Lets declare a state for the List component - var isDone = false;
			When the user has completed the listed task, he strikes the List item by clicking on the List component. So the UI must change from the normal paragraph string to striked paragraph string. This can be achieved by leveraging the state isDone. 
			On the click of the user the isDone must change to true. 
			When isDone = true; We can change the styling of paragraph component by adding the class (or in case with inline styling adding the object to the style prop.) using ternary operator which sets the textDecoration to line-through.
			
			for eg:
			function App() {
				var isDone = false;
				return <p style={ isDone ? { textDecoration : "line-through" } : null}>Bring some vegetables from the market</p>;
			}
			
		This type of programming is known as Declarative Programming because we are declaring how our User Interface should look under different conditions dependent upon States.
		
		Imperative Programming: 
			Instead of declaring how our UI should look based on the state of the variables there is other way we can make changes to the UI.
			for eg- 
			function strike() {
				document.getElementById("root").style.textDecoration = "line-through";
			}
			
			function unStrike() {
				document.getElementById("root").style.textDecoration = null;
			}
			
			function App() {
				return <p>Bring some vegetables from the market</p>;
			}
			
			<button onClick={strike}>Done</button>
			<button onClick={unStrike}>Not Done</button>
			
			This is imperative(unavoidable), here we are getting hold of the element in the dom and changing its property.
			
			But lets see if we get the same results with the Buttons if we use Declarative Programming.
			
			var isDone = false;
			
			function strike() {
				isDone = true;
			}
			
			function unStrike() {
				isDone = false;
			}
			
			function App() {
				return <p style={isDone ? { textDecoration : "line-through" } : null}>Bring some vegetables from the market</p>;
			}
			
			<button onClick={strike}>Done</button>
			<button onClick={unStrike}>Not Done</button>
			
			In this case even if we click on Done button the isDone will get equal to true but the UI will not change. This is because the <p> element is already been created and rendered on the UI and now it has nothing to do with the isDone state or variable. Because the scope of isDone is till deciding weather the styling has to be applied or not. Once the expression gets evaluated the <p> has nothing to do with the isDone state or variable. Here isDone playes its role at the time of creation of the <p> element and nothing further.
			
			But this problem or rather puzzle can be solved by re-rendering the elements for their changed properties and this can be done using Hooks.
			
			Hooks are functions that allow us to hook into the state of our app and read or modify it. 
			

# React Hooks

	We have this code which renders a h1 and button.
	
	import React from "react";
	import ReactDOM from "react-dom";

	ReactDOM.render(
		<div className="container">
			<h1>0</h1>
			<button>+</button>
		</div>,
		document.getElementById("root")
	);
	
	We want our button to increase the number in h1. But with the above lines of code we couldnt do it. Because we have hard coded the number in h1.
	There is one way we can approach this problem- We should maintain the count variable to increment its value by 1 each time the user clicks on the button and use this count variable inside h1.But the job is not done yet. We have to use the onClick attribute or property of the button to listen for the click and perform an action. And in this case the action is to increament the value of count by 1. Lets see what happens
	
	import React from "react";
	import ReactDOM from "react-dom";
	
	var count = 0;
	
	function increament() {
		count++;
		console.log(count);
	}
	
	ReactDOM.render(
		<div className="container">
			<h1>{count}</h1>
			<button onClick={increament}>+</button>
		</div>,
		document.getElementById("root")
	);
	
	The above code will increament the count by 1 when the button gets clicked.
	But we will witness that on the UI that even if we click on the button multiple times the UI displaying 0 does not change even though the count is getting increamented.
	This is because the jsx elements are already rendered and it needs to be rerendered to display the changes in the state. So we can do this:
	
	import React from "react";
	import ReactDOM from "react-dom";
	
	var count = 0;
	
	function increament() {
		count++;
		ReactDOM.render(
			<div className="container">
				<h1>{count}</h1>
				<button onClick={increament}>+</button>
			</div>,
			document.getElementById("root")
		);
	}
	
	ReactDOM.render(
		<div className="container">
			<h1>{count}</h1>
			<button onClick={increament}>+</button>
		</div>,
		document.getElementById("root")
	);
	
	The above code rerenders the jsx elements when the user cliks on the button to display for the changes in the state. 
	But this method is insufficient because for only one state or variable the whole page is getting re-rendered. And also the code has become redundant.
	
	This issue is resolved using HOOKS!
	As we know Hooks are special react functions.
	But we can only use hooks inside functional components. We need to convert the above code into modular.
	
	App.jsx
	import React from "react";
	
	function App(){
		return (
			<div className="container">
			<h1>0</h1>
			<button onClick={increament}>+</button>
		</div>
		);
	}
	
	export default App;
	
	index.js
	
	import React from "react";
	import ReactDOM from "react-dom";
	
	ReactDOM.render(
		<App />,
		document.getElementById("root")
	);
	
	Now the code is all set to use React Hooks.
	
	Conversation with Chatgpt:
	
	Q) Correct me if my understanding is wrong on react hooks. The hooks are nothing but special functions in react. For eg- useState(), This hook returns an array containing two elements. The first element is the state and the second is the function. So the state is created by the hook itself. We do not create it. We just pass the initial value to define the state. The value is passed through the useState() function by passing the value. And we can use this state in our website to display data. Now if we want to change the value of the state, we can do it by using the 2nd element of the array returned by the useState which is nothing but the function. Using this function we can change the value of the state defined by the hook by passing the new value through it. Now this operation will not only change the value of the state it will also get noticed by the react and then the react will re-render the elements which are using this state. Only those elements will get rendered which are using the state's value and not the whole component.
	
	A) Your understanding of React hooks, particularly `useState()`, is mostly correct! Let's break it down:

	1. **What are React Hooks?**: React hooks are special functions that allow you to use state and other React features in functional components. They enable functional components to have state and lifecycle features that were previously only available in class components.

	2. **`useState()` Hook**: This hook is used to add state to functional components. It takes the initial state as an argument and returns an array containing two elements:
		- The first element is the current state value.
		- The second element is a function that allows you to update the state.

	3. **Usage of `useState()`**: You're correct that you don't create the state yourself; `useState()` creates it for you. You pass the initial value of the state as an argument to `useState()`. This hook returns an array, and you typically use array destructuring to access the state value and the function to update it.

	4. **Updating State**: You update the state by calling the function returned by `useState()`, passing the new value as an argument. When you update the state using this function, React automatically re-renders the component and any other components that depend on that state value.

	5. **Component Re-rendering**: React intelligently re-renders only the parts of the component tree that are affected by state changes. This means that not the entire component or application gets re-rendered, but only the necessary parts based on the state changes.

	Overall, your understanding of `useState()` and how React handles state updates and component re-rendering is accurate. Keep in mind that React hooks provide a powerful way to manage state and other React features in functional components, making them more versatile and easier to work with.
	
	Q) So is this the part were diffing algorithm plays it's role?
	A) The diffing algorithm plays a crucial role in React's rendering process, including when using hooks like useState().

	When you update the state using useState() or any other means in React, React uses its diffing algorithm to efficiently determine the minimal set of changes needed to update the UI. This algorithm compares the previous Virtual DOM (which represents the UI state before the update) with the updated Virtual DOM (which represents the UI state after the update) to identify the differences.

	Based on the differences identified during this comparison, React calculates the minimal set of changes needed to update the Real DOM (the actual browser DOM) to reflect the updated UI state. React then applies these changes to the Real DOM, selectively updating only the parts of the UI that have changed.

	So, when you update the state using useState() and React re-renders the component to reflect the state change, the diffing algorithm ensures that only the necessary parts of the UI are updated, optimizing performance by minimizing unnecessary re-renders. This helps React efficiently manage UI updates and maintain a responsive user experience, even in complex applications with dynamic data and frequent UI changes.
	
	Q)I had one doubt. If we call the function provided by the useState to update the state value. The variable used to refer the state value in destructuring  for eg:- const [count, setCount] = useState(0); will also receive the changed value right? Means the above line of code will be executed again to set the updated value of the count? Is my understanding right?
	A) When you call the function provided by useState() to update the state value (e.g., setCount(newValue)), React will re-render the component, and the line of code where you initially declared the state using useState() (e.g., const [count, setCount] = useState(0);) will be executed again to set the updated value of the state variable (count).

	This is because React treats state updates as asynchronous, and updating the state triggers a re-render of the component to reflect the updated state. During this re-render, the component's code is re-executed from top to bottom, including the line where the state variable is declared and initialized using useState(). As a result, the updated state value will be assigned to the state variable (count in this case), and any subsequent code referencing this state variable will reflect the updated value.

	So, in summary, calling the function provided by useState() to update the state value triggers a re-render of the component, and the state variable will receive the updated value during this re-render.
	
	Q) So when react re-executes the component code once the state value gets updated. How it handles the  const [count, setCount] = useState(0); line? Because the line contains an hard coded value. Would it not set again the value to 0 since this line is getting executed once more
	A)When React re-renders a component, it does indeed re-execute the entire functional component body, including the line where the state is initialized using useState(). However, the initialization of state with useState() only happens during the initial render of the component, not during subsequent re-renders.

	During subsequent re-renders caused by state updates, React does not reinitialize the state. Instead, it preserves the current state values. This means that when the line const [count, setCount] = useState(0); is re-executed during a re-render, React does not reset the state value to 0. Instead, it returns the current state value (the updated value, if it has been changed during the component's lifecycle).
	

	Q) React Fibre's incremental rendering feature:
	A) Absolutely! Let's simplify it:

	Imagine you're building a really big Lego model. Instead of trying to build the entire model in one go, which can be overwhelming and take a long time, you decide to break it down into smaller, more manageable sections.

	Similarly, React's incremental rendering feature (implemented with React Fiber) works like this:

	1. **Chunking the Work**: When React needs to update the user interface (UI) in response to changes (like when data changes or user interactions occur), it doesn't try to do everything all at once.

	2. **Breaking Down the Task**: Instead, React breaks down the task of updating the UI into smaller pieces, or "chunks." Each chunk represents a part of the UI that needs to be updated.

	3. **Spreading it Out**: React then spreads out these chunks of work over multiple frames, or "time slots." It doesn't try to complete all the work in a single frame (which could cause the UI to freeze or become unresponsive).

	4. **Gradual Updates**: By spreading out the work over multiple frames, React can gradually update the UI without blocking the main thread of the browser. This helps maintain a smooth and responsive user experience, even when there are complex tasks like animations or layout calculations happening in the background.

	In simpler terms, incremental rendering in React is like building a big Lego model one small piece at a time, instead of trying to do it all in one go. This approach helps keep the UI responsive and prevents it from freezing or becoming sluggish, especially when dealing with complex tasks.
	
	* Other features of React Fibre: Other key features include the ability to pause, abort, or reuse work as new updates come in; the ability to assign priority to different types of updates; and new concurrency primitives.
	
	Q) Reconcilation Algorithm (Diffing algorithm) Explained : Source- https://github.com/acdlite/react-fiber-architecture
	A) 
	reconciliation
	The algorithm React uses to diff one tree with another to determine which parts need to be changed.
	update
	A change in the data used to render a React app. Usually the result of `setState`. Eventually results in a re-render.
	
	Reconciliation is the algorithm behind what is popularly understood as the "virtual DOM." A high-level description goes something like this: when you render a React application, a tree of nodes that describes the app is generated and saved in memory. This tree is then flushed to the rendering environment â€” for example, in the case of a browser application, it's translated to a set of DOM operations. When the app is updated (usually via setState), a new tree is generated. The new tree is diffed with the previous tree to compute which operations are needed to update the rendered app.

# Javascript ES6 Object and Array Destructuring

Why destructuring is useful?
We will understand it with the help of array destructuring.
99.99% of the times we fetch the values in an array is using its indices: name[index]. This is the one way to fetch the value from an array.
The new ES6 features provides another way to fetch these values. That is through Destructuring the array. In destructuring of array we map the variables to the elements of an array. So that there is no need to represent the intems inside the array using its indices. It does add meaning to our code. Because suppose our array contains  the data related to an animal: cat,meow,etc. So referencing the cat using animal[0] doesnt make sense. But instead if we just represent the data with the special variables like: animal for the first index data and sound for the 2nd index value, it makes sense.

This is how we destructure an array.
const amimals=[{animal: cat, sound: meow},{animal: dog, sound: bhow}]
if we want to fetch the meow from above array normally we will use : animals[0].sound; 
The above line doesnt tell that we are fetching the data related to the sound of cat.
But if we fetch it in the way as shown below:
First we will have to destructure an array
const [cat, dog]=[{animal: cat, sound: meow},{animal: dog, sound: bhow}];
Now to fetch the meow we will write: cat.sound; This line clearly tells the developer that the data which is fetched here is relate to the cats sound which can be meow.
In this way the destructuring of the arrays and objects help the developers.

A] Destructuring an Array
const [name, age] = [yash, 12];
console.log(name); -> yash
console.log(age);  -> 12


B] Destructuring an Object
const {name, age, education} = {name: yash, age: 12, education: high school};
console.log(name); -> yash
console.log(age);  -> 12
console.log(education);  -> high school

Note that in case of Object Destructuring the name of the variables must be same as its properties.
Suppose if we want to provide the custom names to the properties of an object, just specify the actual name so that the compiler maps the property we are trying to map and using colon specify the custom name. for eg:
const {name : myName, age : myAge, education : myEducation} = {name: yash, age: 12, education: high school};
console.log(myName); -> yash
console.log(myAge);  -> 12
console.log(myEducation);  -> high school

Giving default values to the properties of an object. This will prevent our website from crashing if any of the properties are not defined. 
const {name="Fluffy", sound="meow"};
If name is not defined - console.log(name); -> Fluffy      And if name is defined to cat -> cat


#React Forms:

Through forms arise complex events. In react we need to handle or make use of these complex events and also use the knowledge of state to get our forms work as normal. Because the way the forms work in react is preety different from the normal html forms. Cause the html form elements like <input>, <select> and <textarea> in html can update there state themselves when the user makes changes to them. For eg if the user changes the text inside the input, then the input element updates the value of its value attribute automatically. But when we try to create forms using react we cant manage or handle the user entered data in the react unless we gain access to the data from orignal html forms using event and event handlers. Because the react form component does not have its own ability to( mimic the real html forms) reflect the changes made by the user in the UI and use this to control the UI. Thus we have to make our react forms to mimic the normal html forms explicitly.

For eg:
import React, {useState} from "react";

function App() {

  return (
    <div className="container">
      <h1>Hello </h1>
      <input type="text" placeholder="What's your name?" />
      <button>Submit</button>
    </div>
  );
}

export default App;

The result of the above code will be: The react will execute this code to render the form on the UI. Means this code in the end will finally result in creating the corresponding html elements for the given jsx elements. Now the created html elements for eg: the <input> element will change its state automatically with the user interaction. But these changes are not reflected to our main component which created this form. Because once the component is rendered its output has nothing to do with the component. There is no pipeline which connects the real html form to the react form component to access the real forms data. We have to explicitly create this pipeline using events and eventhandlers. We can access the data user entered using complex events. We can make use of the onChange event to listen for the user interaction with the input element and use it get access to the user entered data. for eg:

import React from "react";

function App() {

  function handleChange(event){
   console.log(event.target.value);      // event: object containing all the information about the event that took place; target: the target refers to the element which triggered this event, in this case it is an input element; value: it is the attribute of the targeted element.
  }

  return (
    <div className="container">
      <h1>Hello </h1>
      <input onChange={handleChange} type="text" placeholder="What's your name?" />
      <button>Submit</button>
    </div>
  );
}

This way we can connect our react form to the actual html form to handle the data. But there is still more work to be done to mimic the acutal html forms. defining the 'value' property for our react input element and setting it equal to the "source of truth" which is nothing but react state we are going to define further. This state is going to keep trak of the value of the real html input element hence called the "source of truth".

import React, {useState} from "react";

function App() {

  const [name, setName] = useState(""); 

  function handleChange(event){
   setName(event.target.value);
  }

  return (
    <div className="container">
      <h1>Hello </h1>
      <input onChange={handleChange} type="text" placeholder="What's your name?" value={name}/> // This element will get rerendered because the react will notice the change in the state i.e. name. 
      <button>Submit</button>
    </div>
  );
}

The Flow will be like:

*The form renders for the first time creating the real form.
*At this time the value of the html input element is defined by the react component itself which is set to "";
*The user interacts with the form by typing the text inside the html input element.
*This triggers the onChange event.
*This event is handeled by the handleChange() event listner or handler. 
*This sets the name state equal to the new value which is the text entered by the user.
*Now this change in state is noticed by the React.
*The React re-renders the elements or things which depends on the name state.
*Thus the <input> element gets re-rendered with new value defined to the user entered text.
*This procedure is repeated for every user interaction causing the events.


* Default html form behaviour and how to handle or prevent it :
When we create an html form and if it is containing only single button. Then by default it will be treated as an "Submit" button even if we do not define it.
When we click on the Submit button. The bydefault behaviour of the form is it will create a post requeste and will refresh the page. This is the default behaviour of the html forms.

To prevent this default behaviour in react we can make our form element trigger or listen the submit form event by defining the "onSubmit" event and handle the event to prevent the default behaviour of forms using the preventDefault() method of the submit event object.


#React Class and Functional Components

Functional Component:
import React from 'react';

function App() {

	return (<h1>Hello</h1>);

}

export default App;

Corresponding Class Component:
import React from 'react';

class App extends React.Component {
	render() {
		return (<h1>Hello</h1>);
	}
}

export default App;

The end effect of class and functional component is the same. But class component method of creating components is more complex and its boiler plate code has more no. of lines compared to the functional component. 

We cant use Hooks inside the class component. 


# Complex States and Changing the Complex state
It is not like the state can only hold the single value. It can also hold complex data like object. The state which can hold complex data like objects are known as Complex States.

There are times we will be using complex states in our application. For eg in our react forms.
Suppose our react form consists of 2 imput elements-(First name and Last name) and 1 submit button. And we want what we enter in these inputs to get displayed inside the header of the form.
This can be achieved by creating two states to hold the two input values. and using these states inside the header.
But what if we have created a long form. This will let us to create more no. of states proportional to the no. of input elements. This makes our code look cluttered and inefficient. Because for every state we would require to create separate handlers to set the new value to the respective states. 

So instead it is a good Idea to use The Complex state. This complex state will be an object. And this object will keep track of all the input fields of our form. So that if any of the input value changes there is only one handler function that needs to be called to update the changed property or input.

But note that to know which input element got changed we must specify name to each input element using the name attribute. It is because we are creating a object to represent the real form. And using this object we are going to update our current react form.

Now in the handler we are going to accept the 'event' object to know which input element just got changed. And then using this info we will change the state to new updated object which has the property which is ressembling the changed input changed to the updated real value. And all other properties set equal to the previous state values.
To change the property to new value is easy.
But to set the rest of the properties to the vales from the previous state is tricky.
For that we need to pass the fat arrow fucntion to setState method and through this function we can pass the prevValue parameter of the react which holds the previous value of the state in it to set the other properties to their previous values. For eg: 

import React, {useState} from "react";

function App() {

  const [fullName, setFullName] = useState({
    fName : "",
    lName : ""
  });

  function updateFullName(event){
    const newValue = event.target.value;
    const changedElement = event.target.name;

    setFullName((prevValue) => {
      if(changedElement === "fName"){
        return {
          fName : newValue,
          lName : prevValue.lName
        };
      } else if(changedElement === "lName"){
        return {
          fName : prevValue.fName,
          lName : newValue
        };
      }
    })
  }
  
  return (
    <div className="container">
      <h1>Hello {fullName.fName} {fullName.lName}</h1>
      <form>
        <input onChange={updateFullName} name="fName" placeholder="First Name" value={fullName.fName}/>
        <input onChange={updateFullName} name="lName" placeholder="Last Name" value={fullName.lName}/>
        <button>Submit</button>
      </form>
    </div>
  );
}

export default App;

* "prevValue" preporty of React holds the previous value of State.

# Spread Operator (...)
The spread (...) syntax allows an iterable, such as an array or string, to be expanded in places where zero or more arguments (for function calls) or elements (for array literals) are expected. In an object literal, the spread syntax enumerates the properties of an object and adds the key-value pairs to the object being created.

Spread syntax can be used when all elements from an object or array need to be included in a new array or object, or should be applied one-by-one in a function call's arguments list. There are three distinct places that accept the spread syntax:

Function arguments list (myFunction(a, ...iterableObj, b))
Array literals ([1, ...iterableObj, '4', 'five', 6])
Object literals ({ ...obj, key: 'value' })


# Managing the Component Tree

We are aware that we can make changes to the child component based on the interaction with the parent component. But can we make changes to the parent component based on the interaction with child component?

The above question is important because the parent component can easily alter the child component by passing props but the opposite is not possible. I.e. we cannot pass props from child component to the parent component to make changes to it. But there is a way or hack we can use to change the parent component based on the interaction with the child component.
Yes, we can change!

Remember we can pass 'props' from parent component to child component to alter the child component based on the parent component's state. We can take advantage of this to change the state of the parent component. 
We can create a function which is responsible to change the state of the parent component inside the parent component. And we can pass it as a 'prop' to the child component. Then the child component can trigger this function anytime to change the state of the parent component.

This way we can change the state of the parent component through the child component.


# Hooks

1. useMemo()

useMemo hook takes two parameters - a function (call back) and array of dependencies (variables or states or props) - if any of these dependencies changes then the function which we have passed gets called between rerender.

The useMemo() returns the value of the call back or memonisation function which we passed as a parameter to it. The useMemo hook is used to prevent the unneccassary calling of the heavy function every time between the rerenders. The useMemo memonizes(remembers) the computed value of the function and it returns this value whenever the it is needed without re-executing the function. It will reexecute the function only when the dependencies change.

// There is a react function to memonize components called "memo()". To memonize the component we pass it to the memo(component) function which does its job by itself and memonizes the component. Now the component will only re-render if and only if its 'props' change. Otherwise it will use the memonized component.  

2. useCallback()

useMemo and useCallback hooks are similar, the only difference is useMemo returns the memonize value and the useCallback returns the memonize function.
useCallback takes function defination as its first parameter and an array of dependencies as its second parameter. The useCallback memonizes the function defination and does not create the new defination untill the dependencis change. The useCallbacks main usecase is to stoping the re-rendering of the component which takes function as a prop. This is because the function will get redefine again during the rerendering of the parent component and react will consider change in the prop of the component because in javaScript two function definations are not equal even though they are same.

3. useEffect() 

The useEffect Hook allows you to perform side effects in your components.
Some examples of side effects are: fetching data and directly updating the DOM, etc..
useEffect accepts two arguments. The second argument is optional.

useEffect(<function>, <dependency>)

a. No dependency passed:

useEffect(() => {
  //Runs on every render
});

b. An empty array:

useEffect(() => {
  //Runs only on the first render
}, []);

c. Props or state values:

useEffect(() => {
  //Runs on the first render
  //And any time any dependency value changes
}, [prop, state]);

Effect Cleanup
We can also return a cleanup function to the useEffect hook to run it when the component gets unmounted.
Some effects require cleanup to reduce memory leaks.
Timeouts, subscriptions, event listeners, and other effects that are no longer needed should be disposed.
We do this by including a return function at the end of the useEffect Hook.

4. useRef()

Use Case 1: useRef() hook is used to persist the value of a refrence variable between rerenders. 
	const ref = useRef(initial value);
	
	Note that useRef() hook returns an object with a property 'current'. This current property is set to whatever the value the user has passed through the useRef(). This ovject is maintained by the React and therefore it does not gets redefined during the rerenders. But we can update the value using dot notation.
	Now in order to use this ref we have to address it throuh ref.current.
	For eg: ref.current = ref.current + 1;
	
Use Case 2: Used to provide the reference to the jsx element.
	const ref = useRef();
	
	<button ref={ref}>Ref</button>
	
	Now we can access the button without any dom manipulation using only ref and manipulate it. There is no need to - document.getElementById... instead we can directly refer it using the ref - ref.current.style.backgroundColor = "red";

	React.dev:
	Parameters 
	initialValue: The value you want the ref objectâ€™s current property to be initially. It can be a value of any type. This argument is ignored after the initial render.
	Returns 
	useRef returns an object with a single property:
	current: Initially, itâ€™s set to the initialValue you have passed. You can later set it to something else. If you pass the ref object to React as a ref attribute to a JSX node, React will set its current property.
	On the next renders, useRef will return the same object.


5. useContext()



#Routing in React

	The question comes why we use react router in the first place if we have the anchor tag. The problem with anchor tag is when we navigate to the new page using anchor tag the whole page reloads. This is not efficient. Therefore we use react router to route to new page(to change page contents) without reloading the whole page.

	To use react router install the following : npm i react-router-dom
	
	Till now we have created single page applications but using router we can create multi page applications.
	
	Now in index.js or main.js: import {createBrowserRouter, RouterProvider} from react-router-dom;
	
	Using createBrowserRouter we will create the router which will route the user to new page without reloading the page. 
	The createBrowserRouter takes an array of objects as its arguement- createBrowserRouter([{path: '/', element: <Home />}, {path: '/About', element: <About />}]).
	
	Wherever we put the RouterProvider the routed components will fit there.
	
	Note that there must not be siblings to the RouterProvider.
	
	Now to add links import 'Link' from 'react-router-dom' and use the <Link to='/'>Home</Link> to create the link/route for the page.
	When the user clicks on the link the Link will request to the router for the corresponding route and the router will fit the component at the RouterProvider.

	If you want to add classes to your links in order to style them use NavLinks instead by importing from react-router-dom. The NavLinks are especially used for Navbar links.
	
	A <NavLink> is a special kind of <Link> that knows whether or not it is "active", "pending", or "transitioning". This is useful in a few different scenarios:

	When building a navigation menu, such as a breadcrumb or a set of tabs where you'd like to show which of them is currently selected
	It provides useful context for assistive technology like screen readers
	It provides a "transitioning" value to give you finer-grained control ove
	
	By default, an active class is added to a <NavLink> component when it is active so you can use CSS to style it.
	
	

#React Redux

